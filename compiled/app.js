// Generated by CoffeeScript 2.7.0
(function() {
  var accidental_key_size, accidentals_in_group, active_chunk_events, active_chunk_n, active_recording_session_id, animate, apply_text_el, arrow_size, cancel_deletion_soon, cancel_learn_range_button, canvas, clear_button, clear_notes, connected_port_ids, control_element, ctx, current_bank_lsb, current_bank_msb, current_instrument, current_notes, current_pitch_bend_value, current_sustain_active, debounce, demo, demo_button, demo_button_start_span, demo_button_stop_span, demo_iid, el, enable_clearing, end_learn_range, export_midi_file, export_midi_file_button, first_save_to_url, fullscreen_button, fullscreen_target_el, gap_size, gaps_in_group, global_bank_lsb_selects, global_bank_msb_selects, global_instrument_selects, global_pitch_bends, global_sustain_periods, group_center, group_of_2_span_size, group_of_3_span_size, group_span_size, hashchange_is_new_history_entry, hue_rotate_degrees, hue_rotate_degrees_input, i, initial_state, input_element, is_accidental, is_group_of_3, is_learning_range, j, k, key_center_x, l, last_note_datetime, layout, layout_radio_buttons, learn_range_or_apply_button, learn_range_text_el, learning_range, len, len1, len2, len3, list_recoverable_recording, load_options, loading_midi_devices_message_el, m, midi_access_failed, midi_access_failed_pre, midi_device_ids_to_rows, midi_devices_table, midi_discovery_iframe, midi_not_supported, midi_range_left_input, midi_range_right_input, nanoid, natural_key_size, no_midi_devices_message_el, no_notes_recorded_message_el, normalize_range, note_gravity_direction, note_gravity_direction_select, notes, nth_accidental, nth_accidental_in_group, nth_accidentals, nth_natural, nth_naturals, octave_key_index, on_error, on_success, perspective_distance, perspective_distance_input, perspective_rotate_vertically, perspective_rotate_vertically_input, piano_accidental_pattern, piano_layout, px_per_second, px_per_second_input, recording_name_input, recover, recoverables_list, recovery_empty_message_el, recovery_error_message_el, ref, ref1, ref2, restore_state, save_chunk, save_options_immediately, save_options_soon, save_state, scale_x, scale_x_input, selected_range, set_pitch_bend, set_selected_range, show_recovery_button, show_recovery_button_loading_indicator, smi, space_between_key_centers, stop_demo, theme, theme_select, troubleshoot_midi_input_button, troubleshoot_midi_input_popover, troubleshooting_popper, undo_clear_button, undo_clear_notes, undo_state, update_options_from_inputs, view_range_while_learning, visualization_enabled, visualization_enabled_checkbox, x1, x2,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
    indexOf = [].indexOf;

  ref = document.querySelectorAll("noscript");
  for (j = 0, len = ref.length; j < len; j++) {
    el = ref[j];
    el.remove(); // for screenreaders
  }

  midi_not_supported = document.getElementById("midi-not-supported");

  midi_access_failed = document.getElementById("midi-access-failed");

  midi_access_failed_pre = document.getElementById("midi-access-failed-pre");

  fullscreen_target_el = document.getElementById("fullscreen-target");

  canvas = document.getElementById("midi-viz-canvas");

  no_notes_recorded_message_el = document.getElementById("no-notes-recorded-message");

  no_midi_devices_message_el = document.getElementById("no-midi-devices-message");

  loading_midi_devices_message_el = document.getElementById("loading-midi-devices-message");

  export_midi_file_button = document.getElementById("export-midi-file-button");

  recording_name_input = document.getElementById("recording-name-input");

  clear_button = document.getElementById("clear-button");

  undo_clear_button = document.getElementById("undo-clear-button");

  show_recovery_button = document.querySelector(".show-recovery-button");

  show_recovery_button_loading_indicator = document.querySelector(".show-recovery-button .loading-indicator");

  recoverables_list = document.getElementById("recoverables");

  recovery_empty_message_el = document.getElementById("recovery-empty-message");

  recovery_error_message_el = document.getElementById("recovery-error-message");

  fullscreen_button = document.getElementById("fullscreen-button");

  visualization_enabled_checkbox = document.getElementById("visualization-enabled");

  px_per_second_input = document.getElementById("note-gravity-pixels-per-second-input");

  note_gravity_direction_select = document.getElementById("note-gravity-direction-select");

  layout_radio_buttons = Array.from(document.getElementsByName("key-layout"));

  theme_select = document.getElementById("theme-select");

  perspective_rotate_vertically_input = document.getElementById("perspective-rotate-vertically-input");

  perspective_distance_input = document.getElementById("perspective-distance-input");

  scale_x_input = document.getElementById("scale-x-input");

  hue_rotate_degrees_input = document.getElementById("hue-rotate-degrees-input");

  midi_range_left_input = document.getElementById("midi-range-min-input");

  midi_range_right_input = document.getElementById("midi-range-max-input");

  learn_range_or_apply_button = document.getElementById("learn-range-or-apply-button");

  learn_range_text_el = document.getElementById("learn-midi-range-button-text");

  apply_text_el = document.getElementById("apply-midi-range-button-text");

  cancel_learn_range_button = document.getElementById("cancel-learn-midi-range-button");

  midi_devices_table = document.getElementById("midi-devices");

  troubleshoot_midi_input_button = document.getElementById("troubleshoot-midi-input-button");

  troubleshoot_midi_input_popover = document.getElementById("troubleshoot-midi-input-popover");

  demo_button = document.getElementById("demo-button");

  demo_button_stop_span = document.getElementById("demo-button-stop-text");

  demo_button_start_span = document.getElementById("demo-button-start-text");

  debounce = function(func, timeout = 300) {
    var tid;
    tid = null;
    return function(...args) {
      clearTimeout(tid);
      return tid = setTimeout((function() {
        return func(...args);
      }), timeout);
    };
  };

  nanoid = function(length = 21) {
    var id, k, len1, n, ref1;
    id = '';
    ref1 = crypto.getRandomValues(new Uint8Array(length));
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      n = ref1[k];
      n = 63 & n;
      id += n < 36 ? n.toString(36) : n < 62 ? (n - 26).toString(36).toUpperCase() : n < 63 ? '_' : '-';
    }
    return id;
  };

  localforage.config({
    name: "MIDI Recorder"
  });

  // for filename
  // - first note would be easier to keep track of but if you record more without clearing, it should be a new filename
  // - time-of-save would be easiest, but then it's harder to know if you've already saved something
  // - END of last note would cause problems if you hit save before releasing a note, or if a note gets stuck
  // - so use START of last note
  // - Date.now() is more performant than new Date()
  last_note_datetime = Date.now();

  // options are initialized from the URL & HTML later
  visualization_enabled = true;

  theme = "white-and-accent-color";

  hue_rotate_degrees = 0;

  layout = "equal";

  px_per_second = 20;

  note_gravity_direction = "up";

  perspective_rotate_vertically = 0;

  perspective_distance = 0;

  scale_x = 1;

  selected_range = [0, 128];

  is_learning_range = false;

  learning_range = [null, null];

  view_range_while_learning = [0, 128];

  normalize_range = function(range) {
    var ref1, ref2, valid_int_0_to_128;
    valid_int_0_to_128 = function(value) {
      var int;
      int = parseInt(value);
      if (isNaN(int) || int < 0 || int > 128) {
        return null;
      }
      return int;
    };
    return [(ref1 = valid_int_0_to_128(range[0])) != null ? ref1 : 0, (ref2 = valid_int_0_to_128(range[1])) != null ? ref2 : 128];
  };

  set_selected_range = function(range, do_not_update_inputs) {
    selected_range = normalize_range(range);
    if (!(is_learning_range || do_not_update_inputs)) {
      return [midi_range_left_input.value, midi_range_right_input.value] = selected_range;
    }
  };

  first_save_to_url = true;

  hashchange_is_new_history_entry = false;

  save_options_immediately = function({update_even_focused_inputs} = {}) {
    var data, from_midi_val, key, old_hash, option_strings, to_midi_val, val;
    [from_midi_val, to_midi_val] = selected_range;
    data = {
      "viz": visualization_enabled ? "on" : "off",
      "layout": layout,
      "gravity-direction": note_gravity_direction,
      "pixels-per-second": px_per_second,
      "3d-vertical": perspective_rotate_vertically,
      "3d-distance": perspective_distance,
      "scale-x": scale_x,
      "midi-range": `${from_midi_val}..${to_midi_val}`,
      "theme": theme,
      "hue-rotate": hue_rotate_degrees
    };
    option_strings = (function() {
      var results;
      results = [];
      for (key in data) {
        val = data[key];
        results.push(`${key}=${val}`);
      }
      return results;
    })();
    old_hash = location.hash;
    hashchange_is_new_history_entry = true;
    if (first_save_to_url) {
      first_save_to_url = false;
      try {
        // avoid hijacking the browser back button / creating an extra step to go back thru
        // when navigating to the app from another site
        // Note: for first URL update we don't need to load_options()
        // since it's loading defaults from elements on the page
        return history.replaceState(null, null, `#${option_strings.join("&")}`);
      } catch (error1) {
        return location.hash = option_strings.join("&");
      }
    } else {
      location.hash = option_strings.join("&");
      if (old_hash === location.hash) {
        // in this case, a hashchange won't occur
        // but we still want to normalize options, at least to be consistent (I'm not sure this is the best behavior, to apply normalization to invalid user inputs)
        // e.g. for MIDI range: 1.0 -> 1, 1.5 -> 1, 1000 -> 128
        return load_options({update_even_focused_inputs});
      }
    }
  };

  save_options_soon = debounce(save_options_immediately);

  load_options = function({update_even_focused_inputs} = {}) {
    var data, k, key, keyval, len1, ref1, ref2, ref3, val;
    data = {};
    ref1 = location.hash.replace(/^#/, "").split("&");
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      keyval = ref1[k];
      if (!(keyval.match(/=/))) {
        continue;
      }
      [key, val] = keyval.split("=");
      key = key.trim();
      val = val.trim();
      data[key] = val;
    }
    
    // For text based inputs, including number inputs,
    // in order to let you backspace and type a new value,
    // don't change the value while focused, only on blur.
    // Except, if you change the option OTHER than via the input,
    // such as if you go back/forward in history,
    // it should update the value of an input even if it's focused.

    // TODO: reset to original defaults when not in URL, in case you hit the back button
    // (maybe merge load_options and update_options_from_inputs in some way?)
    if (data["viz"]) {
      visualization_enabled = (ref2 = data["viz"].toLowerCase()) === "on" || ref2 === "true" || ref2 === "1";
      visualization_enabled_checkbox.checked = visualization_enabled;
    }
    if (data["midi-range"]) {
      set_selected_range(data["midi-range"].split(".."), !update_even_focused_inputs);
    }
    if (data["pixels-per-second"]) {
      px_per_second = parseFloat(data["pixels-per-second"]);
      if (update_even_focused_inputs || document.activeElement !== px_per_second_input) {
        px_per_second_input.value = px_per_second;
      }
    }
    if (data["3d-vertical"]) {
      perspective_rotate_vertically = parseFloat(data["3d-vertical"]);
      if (update_even_focused_inputs || document.activeElement !== perspective_rotate_vertically_input) {
        perspective_rotate_vertically_input.value = perspective_rotate_vertically;
      }
    }
    if (data["3d-distance"]) {
      perspective_distance = parseFloat(data["3d-distance"]);
      if (update_even_focused_inputs || document.activeElement !== perspective_distance_input) {
        perspective_distance_input.value = perspective_distance;
      }
    }
    if (data["scale-x"]) {
      scale_x = parseFloat(data["scale-x"]);
      if (update_even_focused_inputs || document.activeElement !== scale_x_input) {
        scale_x_input.value = scale_x;
      }
    }
    if (data["gravity-direction"]) {
      note_gravity_direction = data["gravity-direction"].toLowerCase();
      note_gravity_direction_select.value = note_gravity_direction;
    }
    if (data["layout"]) {
      layout = data["layout"].toLowerCase();
      if ((ref3 = layout_radio_buttons.find((radio) => {
        return radio.value === layout;
      })) != null) {
        ref3.checked = true;
      }
    }
    if (data["theme"]) {
      theme = data["theme"].toLowerCase();
      theme_select.value = theme;
    }
    if (data["hue-rotate"]) {
      hue_rotate_degrees = parseFloat(data["hue-rotate"]);
      if (update_even_focused_inputs || document.activeElement !== hue_rotate_degrees_input) {
        return hue_rotate_degrees_input.value = hue_rotate_degrees;
      }
    }
  };

  update_options_from_inputs = function() {
    var ref1, ref2;
    visualization_enabled = visualization_enabled_checkbox.checked;
    set_selected_range([midi_range_left_input.value, midi_range_right_input.value], true);
    px_per_second = parseFloat(px_per_second_input.value) || 20;
    hue_rotate_degrees = parseFloat(hue_rotate_degrees_input.value) || 0;
    note_gravity_direction = note_gravity_direction_select.value;
    layout = (ref1 = (ref2 = layout_radio_buttons.find((radio) => {
      return radio.checked;
    })) != null ? ref2.value : void 0) != null ? ref1 : "equal";
    theme = theme_select.value;
    perspective_rotate_vertically = perspective_rotate_vertically_input.value || 0;
    perspective_distance = perspective_distance_input.value || 100;
    // canvas.style.transform = "translate(0, -20px) perspective(50vw) rotateX(-10deg) scale(0.9, 1)"
    // canvas.style.transformOrigin = "50% 0%"
    scale_x = scale_x_input.value || 1;
    canvas.style.transform = `perspective(${perspective_distance}vw) rotateX(-${perspective_rotate_vertically}deg) scaleX(${scale_x})`;
    canvas.style.transformOrigin = "50% 0%";
    return save_options_soon();
  };

  ref1 = [visualization_enabled_checkbox, note_gravity_direction_select, theme_select, ...layout_radio_buttons];
  for (k = 0, len1 = ref1.length; k < len1; k++) {
    control_element = ref1[k];
    control_element.onchange = update_options_from_inputs;
  }

  ref2 = [midi_range_left_input, midi_range_right_input, px_per_second_input, perspective_rotate_vertically_input, perspective_distance_input, scale_x_input, hue_rotate_degrees_input];
  for (l = 0, len2 = ref2.length; l < len2; l++) {
    input_element = ref2[l];
    input_element.oninput = update_options_from_inputs;
    // in case you backspaced an input, it shouldn't change the field while focused, but should when unfocused if still empty
    input_element.onblur = function() {
      // since we're going to load options from the URL, we need to update the URL immediately
      // otherwise you'd need to wait for the debounce timer before unfocusing the input for the change to take
      save_options_immediately();
      return load_options({
        update_even_focused_inputs: true // update_even_focused_inputs is probably not needed here
      });
    };
  }

  load_options({
    update_even_focused_inputs: true
  });

  update_options_from_inputs();

  addEventListener("hashchange", function() {
    load_options({
      update_even_focused_inputs: !hashchange_is_new_history_entry
    });
    return hashchange_is_new_history_entry = false;
  });

  //#############################
  // Connecting to Devices
  //#############################
  midi_device_ids_to_rows = new Map();

  smi = new SimpleMidiInput();

  loading_midi_devices_message_el.hidden = false;

  connected_port_ids = new Set();

  on_success = function(midi) {
    smi.attach(midi);
    //	console.log 'smi: ', smi
    //	console.log 'inputs (as a Map): ', new Map(midi.inputs)
    loading_midi_devices_message_el.hidden = true;
    no_midi_devices_message_el.hidden = false;
    return midi.onstatechange = function(e) {
      var connected, td, tr;
      if (e.port.type === "input") {
        no_midi_devices_message_el.hidden = true;
        connected = e.port.state === "connected" && e.port.connection === "open";
        if (connected) {
          connected_port_ids.add(e.port.id);
        } else {
          connected_port_ids.delete(e.port.id);
        }
        tr = midi_device_ids_to_rows.get(e.port.id);
        if (!tr) {
          tr = document.createElement("tr");
          midi_devices_table.appendChild(tr);
          midi_device_ids_to_rows.set(e.port.id, tr);
        }
        tr.innerHTML = "";
        tr.className = `midi-port midi-device-is-${e.port.state}${connected ? " midi-port-is-open" : ""}`;
        td = document.createElement("td");
        td.setAttribute("aria-label", (connected ? "connected" : "disconnected"));
        td.className = "midi-port-status";
        tr.appendChild(td);
        td = document.createElement("td");
        td.textContent = e.port.name;
        return tr.appendChild(td);
      }
    };
  };

  // auto detect range based on device
  // not sure if I should do this, considering there are instruments that transpose up or down an octave
  // as well as user-explicit transposition
  // if connected
  // 	unless location.hash.match(/midi-range/)
  // 		if e.port.name is "Yamaha Portable G-1"
  // 			set_selected_range([28, 103])

  //			console.log(e.port, e.port.name, e.port.state, e.port.connection)
  on_error = function(error) {
    loading_midi_devices_message_el.hidden = true;
    midi_access_failed_pre.textContent = error;
    midi_access_failed.hidden = false;
    return console.log("requestMIDIAccess failed:", error);
  };

  if (navigator.requestMIDIAccess) {
    navigator.requestMIDIAccess().then(on_success, on_error);
  } else {
    loading_midi_devices_message_el.hidden = true;
    midi_not_supported.hidden = false;
  }

  //#############################
  // State Handling
  //#############################
  notes = [];

  current_notes = new Map();

  current_pitch_bend_value = 0;

  global_pitch_bends = [];

  current_sustain_active = false;

  global_sustain_periods = [];

  current_instrument = void 0;

  current_bank_msb = void 0;

  current_bank_lsb = void 0;

  global_instrument_selects = [];

  global_bank_msb_selects = [];

  global_bank_lsb_selects = [];

  active_recording_session_id = `recording_${nanoid()}`;

  active_chunk_n = 1;

  active_chunk_events = [];

  export_midi_file_button.disabled = true;

  clear_button.disabled = true;

  save_state = function() {
    var state;
    // use JSON to (inefficiently) copy state so that it's not just saving references to mutable data structures
    // Map can't be JSON-stringified
    state = JSON.parse(JSON.stringify({
      notes,
      current_notes: "placeholder for non-serializable Map object",
      current_pitch_bend_value,
      global_pitch_bends,
      current_sustain_active,
      global_sustain_periods,
      current_instrument,
      global_instrument_selects,
      global_bank_msb_selects,
      global_bank_lsb_selects,
      recording_name: recording_name_input.value,
      last_note_datetime,
      active_recording_session_id,
      active_chunk_n,
      active_chunk_events
    }));
    state.current_notes = new Map(current_notes);
    return state;
  };

  restore_state = function(state) {
    // need to make data copy when restoring as well,
    // so that if you restore initial_state it's not going to then mutate that state
    // so that if you clear a second recording it'll work (play notes, clear, play notes, clear)

      // NOTE: these variables must all be declared ABOVE! else they will be local here
    ({notes, current_pitch_bend_value, global_pitch_bends, current_sustain_active, global_sustain_periods, current_instrument, global_instrument_selects, global_bank_msb_selects, global_bank_lsb_selects, last_note_datetime, active_recording_session_id, active_chunk_n, active_chunk_events} = JSON.parse(JSON.stringify(state)));
    current_notes = new Map(state.current_notes);
    return recording_name_input.value = state.recording_name;
  };

  initial_state = save_state();

  undo_state = save_state();

  clear_notes = function() {
    try {
      localStorage[`to_delete:${active_recording_session_id}`] = `cleared ${new Date().toISOString()}`;
    } catch (error1) {}
    undo_state = save_state();
    // TODO: keep current instrument and include instrument select at start of next recording
    // (and update caveat in caveats list)
    restore_state(initial_state);
    export_midi_file_button.disabled = true;
    clear_button.hidden = true;
    undo_clear_button.hidden = false;
    undo_clear_button.focus();
    active_recording_session_id = `recording_${nanoid()}`;
    return active_chunk_n = 1;
  };

  undo_clear_notes = function() {
    restore_state(undo_state);
    export_midi_file_button.disabled = notes.length === 0;
    clear_button.disabled = false;
    clear_button.hidden = false;
    undo_clear_button.hidden = true;
    clear_button.focus();
    try {
      // delete deletion flag to cancel deletion
      // TODO: what about if you already saved it? maybe I should get rid of the separate saving vs clearing?
      return delete localStorage[`to_delete:${active_recording_session_id}`];
    } catch (error1) {}
  };

  enable_clearing = function() {
    clear_button.disabled = false;
    clear_button.hidden = false;
    if (undo_clear_button === document.activeElement) {
      export_midi_file_button.focus();
    }
    return undo_clear_button.hidden = true;
  };

  clear_button.onclick = clear_notes;

  undo_clear_button.onclick = undo_clear_notes;

  set_pitch_bend = function(value, time = performance.now()) {
    var pitch_bend;
    current_pitch_bend_value = value;
    pitch_bend = {time, value};
    global_pitch_bends.push(pitch_bend);
    current_notes.forEach(function(note, key) {
      return note.pitch_bends.push(pitch_bend);
    });
    return enable_clearing();
  };

  //#############################
  // Demonstration Mode
  //#############################
  demo_iid = null;

  stop_demo = function() {
    clearInterval(demo_iid);
    demo_iid = null;
    current_notes.forEach(function(note, note_key) {
      note.end_time = performance.now();
      note.length = note.end_time - note.start_time;
      return current_notes.delete(note_key);
    });
    demo_button_stop_span.hidden = true;
    return demo_button_start_span.hidden = false;
  };

  demo = function() {
    if (demo_iid) {
      stop_demo();
      return;
    }
    demo_button_stop_span.hidden = false;
    demo_button_start_span.hidden = true;
    return demo_iid = setInterval(function() {
      var key, keys_to_be_held, len3, m, n, note, old_note, root, start_time, t, velocity;
      velocity = 127; // range is 0-127, with 0 being equivalent to noteOff
      start_time = performance.now();
      // keys_to_be_held = [
      // 	Math.round(((+Math.sin(start_time / 6400 + Math.sin(start_time / 2345)) + 1) / 2) * 128)
      // 	Math.round(((-Math.sin(start_time / 6400 + Math.sin(start_time / 2345)) + 1) / 2) * 128)
      // ]
      // keys_to_be_held =
      // n for n in [0...128] when (start_time / 500 % n) < 4
      // n for n in [0...128] when ((start_time / 100) % (n * Math.sin(start_time / 6400 + Math.sin(start_time / 2345)) + 1) / 2) < 4
      // n for n in [0...128] when ((start_time / 100) % (n * Math.sin(start_time / 6400 + Math.sin(start_time / 2345)) + 1) / 2) < 4 and (Math.sin(start_time / 6400 + Math.sin(start_time / 2345)) > 0)
      // n for n in [0...128] when ((start_time / 100) % (n * Math.sin(start_time / 6400 + Math.sin(start_time / 2345)) + 1) / 2) < 4 and (Math.sin(start_time / 6400 + Math.sin(start_time / 2345)) > ((n / 128) - 0.5))
      // n for n in [0...128] when ((start_time / 100) % (((n / 128) - 0.5) * Math.sin(start_time / 6400 + Math.sin(start_time / 2345)) + 1) / 2) < 0.1
      // n for n in [0...128] when ((start_time / 1000) % (((n / 128) - 0.5) * Math.sin(start_time / 64000 + Math.sin(start_time / 23450)) + 1) / 2) < 0.1
      // n for n in [0...128] when (
      // 	((start_time / 100) % (((n / 128) - 0.5) * Math.sin(start_time / 6400 + Math.sin(start_time / 2345)) + 1) / 2) < 0.1 and
      // 	Math.abs(Math.sin(start_time / 640 + Math.sin(start_time / 250)) - ((n / 128) - 0.5)) < 0.5
      // )
      // t = start_time / 1000
      // keys_to_be_held =
      // n for n in [0...128] when (
      // 	((t / 1) % (((n / 128) - 0.5) * Math.sin(t / 64 + Math.sin(t / 23)) + 1) / 2) < 0.1 and
      // 	Math.abs(Math.sin(t / 6 + Math.sin(t / 2)) - ((n / 128) - 0.5)) < 0.5
      // )
      t = start_time / 1000;
      // t = t % 4 if t % 16 < 4
      // root = 60 + Math.floor(t / 4) % 4
      // root = 60 + [0, 5, 3, 6][(Math.floor(t / 4) % 4)]
      root = 60 + [0, 5, 3, 6][Math.floor(t / 4) % 4];
      keys_to_be_held = (function() {
        var m, results;
// (n - root) %% 12 < 1
// (n - root) %% 12 < Math.abs(Math.sin(t / 8 + Math.sin(t / 2)) - ((n / 128) - 0.5))
// ((n - root) %% 12) % Math.abs(Math.sin(t / 8 + Math.sin(t / 2)) - ((n / 128) - 0.5)) > 1

        // ((n - root) %% 12) % Math.abs(Math.sin(t / 8 + Math.sin(t / 2)) - ((n / 128) - 0.5)) %% 0.5 < 0.1 and
// ((n - root)) % Math.abs(Math.sin(t / 8 + Math.sin(t / 2)) - ((n / 128) - 0.5)) %% 0.5 < 0.1

        // ((n - root) %% 12) %% (n - t) %% 0.5 < 0.1
// ((n - root) %% 12) %% (-n + t) %% 0.5 < 0.1
        results = [];
        for (n = m = 0; m < 128; n = ++m) {
          if (modulo(modulo(n - root, 12), n & (t / 4)) < modulo(t / 16, 1) && modulo((n - root) % Math.abs(Math.sin(t / 80 + Math.sin(t / 20)) - ((n / 128) - 0.5)), 0.5) < 0.1) {
            // n for n in [0...128] when (
            // 	((t / 1) % (((n / 128) - 0.5) * Math.sin(t / 64 + Math.sin(t / 24)) + 1) / 2) < 0.1 and
            // 	Math.abs(Math.sin(t / 8 + Math.sin(t / 2)) - ((n / 128) - 0.5)) < 0.5
            // )
            results.push(n);
          }
        }
        return results;
      })();
      current_notes.forEach(function(note, note_key) {
        if (indexOf.call(keys_to_be_held, note_key) < 0) {
          note.end_time = performance.now();
          note.length = note.end_time - note.start_time;
          return current_notes.delete(note_key);
        }
      });
      for (m = 0, len3 = keys_to_be_held.length; m < len3; m++) {
        key = keys_to_be_held[m];
        old_note = current_notes.get(key);
        if (!old_note) {
          note = {
            key,
            velocity,
            start_time,
            pitch_bends: [
              {
                time: start_time,
                value: current_pitch_bend_value
              }
            ]
          };
          current_notes.set(key, note);
          notes.push(note);
        }
      }
      // if Math.sin(t * 29) < 0
      // 	set_pitch_bend(Math.sin(t * 4))
      no_notes_recorded_message_el.hidden = true;
      recording_name_input.hidden = false;
      export_midi_file_button.disabled = false;
      return enable_clearing();
    }, 10);
  };

  window.demo = demo;

  window.stop_demo = stop_demo;

  demo_button.onclick = demo;

  //#############################
  // Recording
  //#############################
  cancel_deletion_soon = debounce(function() {
    try {
      return delete localStorage[`to_delete:${active_recording_session_id}`];
    } catch (error1) {}
  });

  smi.on('noteOn', function({event, key, velocity, time}) {
    var note, old_note, ref3, ref4, start_time;
    // Note: noteOn with velocity of 0 is supposed to be equivalent to noteOff in MIDI,
    // but SimpleMidiInput abstracts that away for us, sending a noteOff instead,
    // so we don't need to handle noteOn of 0.
    old_note = current_notes.get(key);
    start_time = time;
    if (old_note) {
      return;
    }
    note = {
      key,
      velocity,
      start_time,
      pitch_bends: [
        {
          time: start_time,
          value: current_pitch_bend_value
        }
      ]
    };
    current_notes.set(key, note);
    notes.push(note);
    no_notes_recorded_message_el.hidden = true;
    recording_name_input.hidden = false;
    export_midi_file_button.disabled = false;
    enable_clearing();
    if (is_learning_range) {
      learning_range[0] = Math.min((ref3 = learning_range[0]) != null ? ref3 : key, key);
      learning_range[1] = Math.max((ref4 = learning_range[1]) != null ? ref4 : key, key);
      [midi_range_left_input.value, midi_range_right_input.value] = learning_range;
    }
    last_note_datetime = Date.now();
    // clear delete flag in case you already exported and are playing more
    return cancel_deletion_soon();
  });

  smi.on('noteOff', function({event, key, time}) {
    var note;
    note = current_notes.get(key);
    if (note) {
      note.end_time = time;
      note.length = note.end_time - note.start_time;
    }
    return current_notes.delete(key);
  });

  smi.on('pitchWheel', function({event, value, time}) {
    return set_pitch_bend(value / 0x2000, time);
  });

  smi.on('programChange', function({program, time}) {
    current_instrument = program;
    global_instrument_selects.push({
      time,
      value: program,
      bank_msb: current_bank_msb,
      bank_lsb: current_bank_lsb
    });
    return enable_clearing();
  });

  smi.on('global', function({event, cc, value, time, data}) {
    var active, ref3;
    if (event !== 'clock' && event !== 'activeSensing') {
      // console.log({event, cc, value, time, data})
      active_chunk_events.push({data, time});
    }
    if (event === "cc" && cc === 0) {
      current_bank_msb = value;
      global_bank_msb_selects.push({
        time,
        value: value
      });
      enable_clearing();
    }
    if (event === "cc" && cc === 32) {
      current_bank_lsb = value;
      global_bank_lsb_selects.push({
        time,
        value: value
      });
      enable_clearing();
    }
    if (event === "cc" && cc === 64) {
      active = value >= 64; // ≤63 off, ≥64 on https://www.midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2
      if (current_sustain_active && !active) {
        if ((ref3 = global_sustain_periods[global_sustain_periods.length - 1]) != null) {
          ref3.end_time = time;
        }
      } else if (active && !current_sustain_active) {
        global_sustain_periods.push({
          start_time: time,
          end_time: void 0
        });
        enable_clearing();
      }
      return current_sustain_active = active;
    }
  });

  //#############################
  // Recording Recovery
  //#############################
  save_chunk = function() {
    var saving_chunk_id, saving_chunk_n;
    // console.log "saving chunk", active_chunk_events
    if (active_chunk_events.length === 0) {
      return;
    }
    saving_chunk_n = active_chunk_n;
    saving_chunk_id = `chunk_${saving_chunk_n.toString().padStart(5, "0")}`;
    localforage.setItem(`${active_recording_session_id}:${saving_chunk_id}`, active_chunk_events).catch(function(error) {
      // TODO: maybe restore active_chunk_events/active_chunk_n in case the error was a fluke (disk busy etc.)?
      // but what if some specific event caused it to fail? in that case it would be better if it could still save further chunks,
      // even if it has to drop some chunks; maybe try again once or twice and then give up on the chunk(s)?
      // That's probably too complicated to handle, creating more bugs than it solves.
      recovery_error_message_el.hidden = false;
      recovery_error_message_el.textContent = `Failed to save recording chunk ${saving_chunk_n} (for recovery)`;
      return console.log(`Failed to save recording chunk ${saving_chunk_n}`);
    });
    // Note: CANNOT do active_chunk_events.length = 0,
    // because localforage.setItem uses the object asynchronously
    // and would save chunks with no notes/events in them!
    active_chunk_events = [];
    active_chunk_n += 1;
    try {
      // DON'T CHANGE THIS without also changing code that assumes "name" is an iso datetime string
      return localStorage[`name:${active_recording_session_id}`] = new Date(last_note_datetime).toISOString(); //.replace(/:/g, "").replace(/\..*Z/, "Z")
    } catch (error1) {}
  };

  setInterval(save_chunk, 1000);

  recover = async function(recoverable) {
    var chunk, event, len3, len4, len5, m, o, original_clear_button_disabled, original_clear_button_hidden, original_export_midi_file_button_disabled, original_focus, original_no_notes_recorded_message_el_hidden, original_recording_name_input_hidden, original_state, original_undo_clear_button_hidden, p, recovered_chunk_events, recovered_events, ref3;
    // TODO: separate concerns, avoid affecting app state
    // maybe ditch SimpleMidiInput.js
    original_state = save_state();
    original_focus = document.activeElement;
    original_clear_button_hidden = clear_button.hidden;
    original_clear_button_disabled = clear_button.disabled;
    original_undo_clear_button_hidden = undo_clear_button.hidden;
    original_no_notes_recorded_message_el_hidden = no_notes_recorded_message_el.hidden;
    original_recording_name_input_hidden = recording_name_input.hidden;
    original_export_midi_file_button_disabled = export_midi_file_button.disabled;
    restore_state(initial_state);
    try {
      // console.log "saved state; starting recover"
      active_recording_session_id = recoverable.recoverable_id;
      recoverable.chunks.sort(function(a, b) {
        return a.n - b.n;
      });
      // TODO: optimize with https://github.com/localForage/localForage-getItems
      // but make sure to keep order of chunks
      recovered_events = [];
      ref3 = recoverable.chunks;
      for (m = 0, len3 = ref3.length; m < len3; m++) {
        chunk = ref3[m];
        recovered_chunk_events = (await localforage.getItem(chunk.key));
        recovered_events = recovered_events.concat(recovered_chunk_events);
        chunk.events = recovered_chunk_events;
        for (o = 0, len4 = recovered_chunk_events.length; o < len4; o++) {
          event = recovered_chunk_events[o];
          if (event.timeStamp == null) {
            event.timeStamp = event.time;
          }
        }
      }
      for (p = 0, len5 = recovered_events.length; p < len5; p++) {
        event = recovered_events[p];
        smi.processMidiMessage(event);
      }
      // recording_name_input.value = "recovered"
      return export_midi_file("recovered", (recoverable.name || "recording").replace(/:/g, "").replace(/\..*Z/, "Z") + " [recovered].midi");
    } finally {
      // console.log "restoring state from recover"

      // all of this could be avoided if UI concerns were separated from MIDI input and export
      restore_state(original_state);
      clear_button.hidden = original_clear_button_hidden;
      clear_button.disabled = original_clear_button_disabled;
      undo_clear_button.hidden = original_undo_clear_button_hidden;
      no_notes_recorded_message_el.hidden = original_no_notes_recorded_message_el_hidden;
      recording_name_input.hidden = original_recording_name_input_hidden;
      export_midi_file_button.disabled = original_export_midi_file_button_disabled;
      if (original_focus != null) {
        original_focus.focus();
      }
    }
  };

  // console.log "restored state from recover"
  list_recoverable_recording = function(recoverable) {
    var dismiss_button, li, recover_button, ref3, span;
    li = document.createElement("li");
    li.classList.add("recoverable-recording");
    span = document.createElement("span");
    span.classList.add("recoverable-recording-name");
    span.textContent = (ref3 = recoverable.name) != null ? ref3 : recoverable.recoverable_id;
    recoverables_list.appendChild(li);
    recover_button = document.createElement("button");
    recover_button.classList.add("button-functional");
    recover_button.innerHTML = `<span class="button-visual">
	<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16">
		<g stroke-width="48.857" transform="translate(-3.631 -5.26) scale(.02225)">
			<path class="fill-cc" d="M301.429 312.422l372.684-76v103.929l-372.684 76z"/>
			<path class="fill-cc" d="M301.429 312.342h60v388.5h-60z"/>
			<ellipse class="fill-cc" cx="-165" cy="470.362" rx="125" ry="78" transform="matrix(.77274 -.20706 .24886 .92877 273.331 240.338)"/>
			<path class="fill-cc" d="M614.113 248.877h60v388.5h-60z"/>
			<ellipse class="fill-cc" cx="-165" cy="470.362" rx="125" ry="78" transform="matrix(.77274 -.20706 .24886 .92877 586.016 176.873)"/>
		</g>
		<path class="fill-cc" fill-rule="evenodd" d="M12.613 9.426c-.125.561-.347 1.012-1.258 1.585v1.165H9.033l3.485 3.838L16 12.176h-2.322v-2.75z"/>
	</svg>
	Save MIDI File
</span>`;
    dismiss_button = document.createElement("button");
    dismiss_button.classList.add("button-functional");
    dismiss_button.innerHTML = `<span class="button-visual">
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
		<path class="fill-cc" d="M39.294 63.922c-5.91-.629-11.383-2.047-16.826-4.362-1.553-.66-4.626-2.198-5.977-2.99-4.008-2.35-7.353-4.936-10.39-8.035-1.735-1.77-3.048-3.3-3.357-3.91-.179-.353-.194-.438-.194-1.068 0-.613.018-.722.177-1.046.253-.513.57-.856 1.008-1.09.475-.252.926-.324 2.336-.373 3.303-.113 6.816-.77 10.27-1.922 4.89-1.63 8.196-3.606 10.903-6.513.618-.663 1.02-1.184 1.91-2.475.359-.52.69-.953.69-.953l4.228 2.034s-1.344 2.408-2.02 3.307c-4.042 5.372-11.416 9.262-20.634 10.885-.538.095-1.033.195-1.101.222-.104.042-.01.155.62.743 1.15 1.075 4.54 3.748 4.994 3.94.338.141.788.103 1.687-.143 1.986-.544 3.686-1.4 5.189-2.614.564-.455.587-.438.266.204-.452.905-1.627 2.507-2.997 4.088-.333.384-.605.716-.605.738 0 .023.609.336 1.353.696.744.36 1.808.9 2.364 1.2 1.165.63 1.74.81 2.58.81 1.035 0 2.04-.292 3.53-1.023 2.286-1.122 4.338-2.58 7.467-5.306l.309-.268-.127.368c-.446 1.296-1.746 3.565-3.897 6.802-.626.944-1.129 1.726-1.116 1.738.14.134 6.29 1.275 6.87 1.275.363 0 .552-.184 1.181-1.147 2.265-3.465 4.403-7.518 6.223-11.797.612-1.438.874-2.117 1.927-4.981.48-1.306.9-2.712.921-2.733.021-.022 4.55 1.83 4.58 1.856.067.058-1.255 3.727-2.134 5.923-2.08 5.193-4.356 9.659-7.103 13.94-.827 1.289-1.915 2.807-2.283 3.187-.646.667-1.569.926-2.822.793z"/>
		<path class="fill-cc-if-disabled" fill="red" d="M43.467 30.744c-6.402-2.85-11.665-5.19-11.696-5.202-.08-.028.23-.628.663-1.282 1.021-1.545 2.807-2.714 4.856-3.178.674-.153 2.13-.153 2.852 0 .852.181 1.344.37 3.945 1.513 4.675 2.054 7.29 3.248 7.909 3.61a7.62 7.62 0 013.693 5.22c.13.69.132 1.969.002 2.715-.099.563-.474 1.789-.548 1.787-.02-.001-5.274-2.333-11.676-5.183z"/>
		<path class="fill-cc" d="M47.999 20.662c-2.008-.897-3.687-1.666-3.731-1.709-.063-.06.954-2.015 4.703-9.043C51.8 4.608 53.853.83 53.996.665c.382-.44.681-.565 1.339-.56a4 4 0 012.68 1.052c.494.457.71.89.71 1.421 0 .367-.296 1.221-3.45 9.925-3.1 8.556-3.56 9.805-3.61 9.793-.008-.002-1.658-.737-3.666-1.634z"/>
	</svg>
	Clear
</span>`;
    li.appendChild(recover_button);
    li.appendChild(span);
    li.appendChild(dismiss_button);
    recover_button.onclick = function() {
      var error;
      try {
        recover(recoverable);
        // don't remove if error occurred,
        // to let you retry and (probably) see there error message again,
        // and because it'd just be confusing for it to show up later
        li.remove();
        if (recoverables_list.children.length === 0) {
          show_recovery_button.disabled = true;
          return recovery_empty_message_el.hidden = false;
        }
      } catch (error1) {
        error = error1;
        alert(`An error occured.\n\n${error}`);
        return console.log("Error during recovery:", error);
      }
    };
    return dismiss_button.onclick = function() {
      var error;
      try {
        localStorage[`to_delete:${recoverable.recoverable_id}`] = `cleared_from_recovery ${new Date().toISOString()}`;
        // don't remove if error occurred,
        // to let you retry and (probably) see there error message again,
        // and because it'd just be confusing for it to show up later
        li.remove();
        if (recoverables_list.children.length === 0) {
          show_recovery_button.disabled = true;
          return recovery_empty_message_el.hidden = false;
        }
      } catch (error1) {
        error = error1;
        alert(`Failed to dismiss recoverable recording.\n\n${error}`);
        return console.log("Failed to dismiss recoverable recording:", error);
      }
    };
  };

  // TODO: setTimeout based error handling; promise can neither resolve nor reject (an issue I experienced on Ubuntu, which resolved once I restarted my computer)
  // Update: but it can also take a really long time and succeed :(
  localforage.keys().then(async function(keys) {
    var chunk, key, len3, len4, len5, len6, m, match, o, p, q, recoverable, recoverable_chunk_n, recoverable_id, recoverables, recoverables_to_delete, ref3, ref4, results, should_delete;
    recoverables = {};
    for (m = 0, len3 = keys.length; m < len3; m++) {
      key = keys[m];
      match = key.match(/(recording_[^:]+):chunk_(\d+)/);
      if (match) {
        recoverable_id = match[1];
        recoverable_chunk_n = parseInt(match[2], 10);
        if (recoverables[recoverable_id] == null) {
          recoverables[recoverable_id] = {
            chunks: [],
            recoverable_id
          };
        }
        recoverables[recoverable_id].chunks.push({
          n: recoverable_chunk_n,
          key
        });
      }
    }
    // else
    // 	console.log "Not matching key:", key
    recoverables_to_delete = [];
    for (recoverable_id in recoverables) {
      recoverable = recoverables[recoverable_id];
      should_delete = (function() {
        try {
          return localStorage[`to_delete:${recoverable_id}`];
        } catch (error1) {}
      })();
      recoverable.name = (function() {
        try {
          return localStorage[`name:${recoverable_id}`];
        } catch (error1) {}
      })();
      if (should_delete) {
        recoverables_to_delete.push(recoverable);
      } else {
        show_recovery_button.disabled = false;
        recovery_empty_message_el.hidden = true;
        list_recoverable_recording(recoverable);
      }
    }
    show_recovery_button_loading_indicator.hidden = true;
// after we've updated the screen (theoretically),
// delete old recordings
// TODO: don't delete until after some period after it's marked for deletion, like days maybe?
// (note: make sure to consider delete flag clean up when implementing that)
    for (o = 0, len4 = recoverables_to_delete.length; o < len4; o++) {
      recoverable = recoverables_to_delete[o];
      ref3 = recoverable.chunks;
      for (p = 0, len5 = ref3.length; p < len5; p++) {
        chunk = ref3[p];
        await localforage.removeItem(chunk.key);
      }
      try {
        delete localStorage[`to_delete:${recoverable_id}`];
      } catch (error1) {}
      try {
        delete localStorage[`name:${recoverable_id}`];
      } catch (error1) {}
    }
    ref4 = Object.keys(localStorage);
    
    // In case IndexedDB is cleared but not localStorage, or whatever,
    // clean up delete flags in localStorage.
    results = [];
    for (q = 0, len6 = ref4.length; q < len6; q++) {
      key = ref4[q];
      if (key.match(/^to_delete:/)) {
        results.push(delete localStorage[key]);
      } else {
        results.push(void 0);
      }
    }
    return results;
  // TODO: allow recovering all recordings at once? but always recover in serial in case of its too much to store all in memory
  }, function(error) {
    show_recovery_button_loading_indicator.hidden = true;
    recovery_error_message_el.hidden = false;
    // recovery_error_message_el.textContent = "Failed to list recoverable recordings. #{error}"
    recovery_error_message_el.textContent = `Recovery not available. Make sure you have local storage enabled for this site. ${error}`;
    // TODO: test what cases this applies to (disabled storage, etc.)
    return console.error("Failed to list keys to look for recordings to recover", error);
  });

  //#############################
  // Rendering (Visualization)
  //#############################
  piano_accidental_pattern = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0].map(function(bit_num) {
    return bit_num > 0;
  });

  // accidental refers to the black keys
  // natural refers to the white keys
  nth_accidentals = [];

  nth_naturals = [];

  nth_accidental = 0;

  nth_natural = 0;

  for (i = m = 0, len3 = piano_accidental_pattern.length; m < len3; i = ++m) {
    is_accidental = piano_accidental_pattern[i];
    if (is_accidental) {
      nth_accidental += 1;
    } else {
      nth_natural += 1;
    }
    nth_accidentals.push(nth_accidental);
    nth_naturals.push(nth_natural);
  }

  // measurements of a keyboard
  // octave_width_inches = 6 + 1/4 + 1/16
  // natural_key_width_inches = octave_width_inches / 7
  // accidental_key_width_inches = 1/2 + 1/16 # measured by the hole that the keys sticks up out of
  // group_of_3_span_inches = 2 + 1/2 + 1/8
  // group_of_2_span_inches = 1 + 3/4 - 1/16

  // group_of_3_span_size = group_of_3_span_inches / octave_width_inches * 12
  // group_of_2_span_size = group_of_2_span_inches / octave_width_inches * 12
  // natural_key_size = 12 / 7
  // accidental_key_size = natural_key_size * accidental_key_width_inches / natural_key_width_inches

  // console.log {group_of_2_span_size, group_of_3_span_size, accidental_key_size}
  // console.log group_of_2_span_size/natural_key_size, group_of_3_span_size/natural_key_size, accidental_key_size/natural_key_size
  // 1.8712871287128714 2.9108910891089113 0.6237623762376237
  natural_key_size = 12 / 7;

  accidental_key_size = natural_key_size * 0.6;

  group_of_2_span_size = natural_key_size * 1.87;

  group_of_3_span_size = natural_key_size * 2.91;

  piano_layout = (function() {
    var len4, o, results;
    results = [];
    for (octave_key_index = o = 0, len4 = piano_accidental_pattern.length; o < len4; octave_key_index = ++o) {
      is_accidental = piano_accidental_pattern[octave_key_index];
      if (is_accidental) {
        nth_accidental = nth_accidentals[octave_key_index];
        is_group_of_3 = nth_accidental > 2;
        accidentals_in_group = is_group_of_3 ? 3 : 2;
        gaps_in_group = accidentals_in_group - 1;
        nth_accidental_in_group = is_group_of_3 ? nth_accidental - 2 : nth_accidental;
        group_center = natural_key_size * (is_group_of_3 ? 5 : 1.5);
        group_span_size = is_group_of_3 ? group_of_3_span_size : group_of_2_span_size;
        gap_size = (group_span_size - accidentals_in_group * accidental_key_size) / gaps_in_group;
        space_between_key_centers = accidental_key_size + gap_size;
        key_center_x = group_center + (nth_accidental_in_group - (accidentals_in_group + 1) / 2) * space_between_key_centers;
        x1 = key_center_x - accidental_key_size / 2;
        x2 = key_center_x + accidental_key_size / 2;
      } else {
        nth_natural = nth_naturals[octave_key_index];
        x1 = (nth_natural - 1) * natural_key_size;
        x2 = (nth_natural + 0) * natural_key_size;
      }
      results.push({x1, x2});
    }
    return results;
  })();

  ctx = canvas.getContext("2d");

  (animate = function() {
    var bar_thickness, bent_x, canvas_visible, container_el, end_y, extremity_midi_val, filter, font_size, form_el, form_el_selector, form_els, get_note_location_canvas_space, get_note_location_midi_space, h, i1, instrument_name, instrument_select, j1, left_midi_val, len10, len11, len12, len4, len5, len6, len7, len8, len9, max_midi_val, midi_to_canvas_scalar, midi_x1, midi_x2, min_midi_val, next_pitch_bend, note, now, o, p, pitch_axis_canvas_length, pitch_bend, point, points, q, r, ref10, ref3, ref4, ref5, ref6, ref7, ref8, ref9, right_midi_val, s, segment_end_bent_x, segment_end_time, smooth, start_y, sustain_period, text, text_background_y, text_width, text_y, time_axis_canvas_length, u, v, w, x, y, y1, y2, z;
    requestAnimationFrame(animate);
    if (is_learning_range) {
      [min_midi_val, max_midi_val] = view_range_while_learning;
    } else {
      [left_midi_val, right_midi_val] = selected_range;
      min_midi_val = Math.min(left_midi_val, right_midi_val);
      max_midi_val = Math.max(left_midi_val, right_midi_val);
    }
    canvas_visible = canvas.style.display === "";
    if (canvas_visible !== visualization_enabled) {
      canvas.style.display = visualization_enabled ? "" : "none";
      ref3 = Array.from(document.querySelectorAll(".disable-if-viz-disabled"));
      for (o = 0, len4 = ref3.length; o < len4; o++) {
        container_el = ref3[o];
        form_el_selector = "input, button, textarea, select";
        form_els = Array.from(container_el.querySelectorAll(form_el_selector));
        if (container_el.matches(form_el_selector)) {
          form_els.push(container_el);
        }
        for (p = 0, len5 = form_els.length; p < len5; p++) {
          form_el = form_els[p];
          form_el.disabled = !visualization_enabled;
        }
        container_el.classList[visualization_enabled ? "remove" : "add"]("disabled");
      }
    }
    if (!visualization_enabled) {
      return;
    }
    filter = `hue-rotate(${hue_rotate_degrees}deg)`;
    if (canvas.style.filter !== filter) {
      canvas.style.filter = filter;
    }
    now = performance.now();
    if (canvas.width !== innerWidth) {
      canvas.width = innerWidth;
    }
    if (canvas.height !== innerHeight) {
      canvas.height = innerHeight;
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    if (note_gravity_direction === "down" || note_gravity_direction === "right") {
      // "that's downright backwards!" haha
      ctx.translate(0, canvas.height);
      ctx.scale(1, -1);
    }
    if (note_gravity_direction === "left" || note_gravity_direction === "right") {
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(Math.PI / 2 * (note_gravity_direction === "left" ? -1 : +1));
      ctx.translate(-canvas.height / 2, -canvas.width / 2);
    }
    pitch_axis_canvas_length = note_gravity_direction === "left" || note_gravity_direction === "right" ? canvas.height : canvas.width;
    time_axis_canvas_length = note_gravity_direction === "left" || note_gravity_direction === "right" ? canvas.width : canvas.height;
    if (left_midi_val > right_midi_val) {
      ctx.translate(pitch_axis_canvas_length, 0);
      ctx.scale(-1, 1);
    }
    ctx.translate(0, time_axis_canvas_length * 4 / 5);
    if (theme === "classic" || theme === "gaudy") {
      ctx.fillStyle = "red";
      ctx.fillRect(0, 1, pitch_axis_canvas_length, 1);
    }
    // ctx.globalAlpha = 0.2
    get_note_location_midi_space = function(note_midi_val) {
      var octave_start_midi_val;
      octave_key_index = modulo(note_midi_val, piano_accidental_pattern.length);
      is_accidental = piano_accidental_pattern[octave_key_index];
      if (layout === "piano") {
        octave_start_midi_val = Math.floor(note_midi_val / 12) * 12;
        ({x1, x2} = piano_layout[octave_key_index]);
        x1 += octave_start_midi_val;
        x2 += octave_start_midi_val;
      } else {
        x1 = note_midi_val;
        x2 = note_midi_val + 1;
      }
      return {x1, x2, is_accidental};
    };
    if (layout === "piano") {
      midi_x1 = get_note_location_midi_space(min_midi_val).x1;
      midi_x2 = get_note_location_midi_space(max_midi_val).x2;
    } else {
      midi_x1 = min_midi_val;
      midi_x2 = max_midi_val + 1;
    }
    midi_to_canvas_scalar = pitch_axis_canvas_length / (midi_x2 - midi_x1);
    get_note_location_canvas_space = function(note_midi_val) {
      ({x1, x2, is_accidental} = get_note_location_midi_space(note_midi_val));
      x1 = (x1 - midi_x1) * midi_to_canvas_scalar;
      x2 = (x2 - midi_x1) * midi_to_canvas_scalar;
      return {
        x: x1,
        w: x2 - x1,
        is_accidental
      };
    };
    for (q = 0, len6 = global_sustain_periods.length; q < len6; q++) {
      sustain_period = global_sustain_periods[q];
      start_y = (sustain_period.start_time - now) / 1000 * px_per_second;
      end_y = (((ref4 = sustain_period.end_time) != null ? ref4 : now) - now) / 1000 * px_per_second;
      ctx.fillStyle = "rgba(128, 128, 128, 0.3)";
      ctx.fillRect(0, start_y, pitch_axis_canvas_length, end_y - start_y);
    }
    for (r = 0, len7 = global_instrument_selects.length; r < len7; r++) {
      instrument_select = global_instrument_selects[r];
      y = (instrument_select.time - now) / 1000 * px_per_second;
      instrument_name = JZZ.MIDI.programName(instrument_select.value, instrument_select.bank_msb, instrument_select.bank_lsb).replace(/\s*\*$/, "").replace(/:$/, ""); // I'm not sure why it has an asterisk at the end // I'm also not sure why some names have a colon at the end
      text = `${instrument_select.value}. ${instrument_name}`;
      if (instrument_select.bank_msb || instrument_select.bank_lsb) {
        // Bank Select LSB is rarely used in practice, so don't show it unless it's set
        if (instrument_select.bank_lsb) {
          text = `${instrument_select.bank_lsb}:${text}`;
        }
        text = `${instrument_select.bank_msb || 0}:${text}`;
      }
      // bar line
      bar_thickness = 2;
      ctx.fillStyle = "rgba(128, 128, 128, 0.6)";
      ctx.fillRect(0, y, pitch_axis_canvas_length, bar_thickness);
      // text metrics
      font_size = 16;
      ctx.font = `${font_size}px sans-serif`;
      ctx.textBaseline = "top";
      text_width = ctx.measureText(text).width * 2;
      text_background_y = y + bar_thickness;
      text_y = y + 5;
      // text background rectangle
      ctx.fillStyle = "rgba(0, 0, 0, 1)";
      ctx.fillRect(0, y + bar_thickness, text_width, font_size + (text_y - text_background_y));
      
      // text
      ctx.fillStyle = "rgba(128, 128, 128, 1)";
      ctx.fillText(text, 5, text_y);
    }
    for (s = 0, len8 = notes.length; s < len8; s++) {
      note = notes[s];
      ({x, w, is_accidental} = get_note_location_canvas_space(note.key, pitch_axis_canvas_length));
      ctx.globalAlpha = note.velocity / 127;
      if (note.length == null) {
        // for ongoing (held) notes, display a bar at the bottom like a key
        // TODO: maybe bend this?
        ctx.fillStyle = (function() {
          switch (theme) {
            case "classic":
            case "classic-gaudy":
              return "#a00";
            case "white":
              return "rgba(255, 255, 255, 0.2)";
            case "white-and-accent-color":
              if (is_accidental) {
                return "rgba(255, 0, 0, 0.5)";
              } else {
                return "rgba(255, 255, 255, 0.2)";
              }
          }
        })();
        ctx.fillRect(x, 2, w, 50000);
      }
      ctx.fillStyle = (function() {
        switch (theme) {
          case "classic":
            if (note.length) {
              return "yellow";
            } else {
              return "lime";
            }
            break;
          case "classic-gaudy":
            if (is_accidental) {
              if (note.length) {
                return "#f79";
              } else {
                return "aqua";
              }
            } else {
              if (note.length) {
                return "yellow";
              } else {
                return "lime";
              }
            }
            break;
          case "white":
            return "white";
          case "white-and-accent-color":
            if (is_accidental) {
              return "rgb(255, 0, 0)";
            } else {
              return "white";
            }
        }
      })();
      smooth = true;
      if (smooth) {
        ctx.beginPath();
        points = [];
        ref5 = note.pitch_bends;
        // data_points = []
        for (i = u = 0, len9 = ref5.length; u < len9; i = ++u) {
          pitch_bend = ref5[i];
          next_pitch_bend = note.pitch_bends[i + 1];
          segment_end_time = (ref6 = (ref7 = next_pitch_bend != null ? next_pitch_bend.time : void 0) != null ? ref7 : note.end_time) != null ? ref6 : now;
          y1 = (pitch_bend.time - now) / 1000 * px_per_second;
          y2 = (segment_end_time - now) / 1000 * px_per_second;
          h = y2 - y1 + 0.5;
          bent_x = x + pitch_bend.value * 2 * midi_to_canvas_scalar;
          segment_end_bent_x = x + (next_pitch_bend != null ? next_pitch_bend : pitch_bend).value * 2 * midi_to_canvas_scalar;
          points.push({
            x: bent_x,
            y: y1
          });
          // data_points.push({x: bent_x, y: y1})
          if (y2 - y1 > 10) {
            points.push({
              x: bent_x,
              y: y2 - 5
            });
          }
          if (i === note.pitch_bends.length - 1) {
            points.push({
              x: bent_x,
              y: y2
            });
          }
        }
        for (v = 0, len10 = points.length; v < len10; v++) {
          point = points[v];
          ctx.lineTo(point.x, point.y);
        }
        for (z = points.length - 1; z >= 0; z += -1) {
          point = points[z];
          ctx.lineTo(point.x + w, point.y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 0.5;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.stroke();
      } else {
        ref8 = note.pitch_bends;
        // debug
        // ctx.globalAlpha = 1
        // ctx.fillStyle = "red"
        // for point in points
        // 	ctx.fillRect(point.x, point.y, 2, 2)
        // ctx.fillStyle = "lime"
        // for point in data_points
        // 	ctx.fillRect(point.x, point.y, 2, 2)
        for (i = i1 = 0, len11 = ref8.length; i1 < len11; i = ++i1) {
          pitch_bend = ref8[i];
          next_pitch_bend = note.pitch_bends[i + 1];
          segment_end_time = (ref9 = (ref10 = next_pitch_bend != null ? next_pitch_bend.time : void 0) != null ? ref10 : note.end_time) != null ? ref9 : now;
          y1 = (pitch_bend.time - now) / 1000 * px_per_second;
          y2 = (segment_end_time - now) / 1000 * px_per_second;
          h = y2 - y1 + 0.5;
          bent_x = x + pitch_bend.value * 2 * midi_to_canvas_scalar;
          ctx.fillRect(bent_x, y1, w, h);
        }
      }
    }
    ctx.globalAlpha = 1;
    if (is_learning_range) {
      for (i = j1 = 0, len12 = learning_range.length; j1 < len12; i = ++j1) {
        extremity_midi_val = learning_range[i];
        if (extremity_midi_val != null) {
          ({x, w} = get_note_location_canvas_space(extremity_midi_val, pitch_axis_canvas_length));
          ctx.fillStyle = "red";
          ctx.fillRect(x, 0, w, time_axis_canvas_length);
        }
      }
    }
    return ctx.restore();
  })();

  //#############################
  // MIDI File Export
  //#############################
  export_midi_file_button.onclick = function() {
    return export_midi_file("saved");
  };

  export_midi_file = function(delete_later_reason, file_name) {
    var BPM, PPQN, bank_lsb_select, bank_msb_select, blob, event, events, first_track_events, instrument_select, iso_date_string, last_time, len10, len4, len5, len6, len7, len8, len9, midi_file, note, o, output_array_buffer, p, pitch_bend, pulses_per_ms, q, r, recording_name, ref3, s, sustain_period, total_track_time_ms, total_track_time_seconds, u, v;
    midi_file = new MIDIFile();
    if (notes.length === 0) {
      if (delete_later_reason === "recovered") {
        // setTimeout to avoid current recording's notes gone while alert is shown
        setTimeout(function() {
          return alert("No notes in recording!");
        });
      } else {
        alert("No notes have been recorded!");
      }
      try {
        localStorage[`to_delete:${active_recording_session_id}`] = `no_notes ${new Date().toISOString()}`;
      } catch (error1) {}
      return;
    }
    events = [];
    for (o = 0, len4 = notes.length; o < len4; o++) {
      note = notes[o];
      events.push({
        // delta: <computed later>
        _time: note.start_time,
        type: MIDIEvents.EVENT_MIDI,
        subtype: MIDIEvents.EVENT_MIDI_NOTE_ON,
        channel: 0,
        param1: note.key,
        param2: note.velocity
      });
      if (note.end_time != null) {
        events.push({
          // delta: <computed later>
          _time: note.end_time,
          type: MIDIEvents.EVENT_MIDI,
          subtype: MIDIEvents.EVENT_MIDI_NOTE_OFF,
          channel: 0,
          param1: note.key,
          param2: 5 // TODO?
        });
      }
    }
// TODO: EVENT_MIDI_CHANNEL_AFTERTOUCH
    for (p = 0, len5 = global_pitch_bends.length; p < len5; p++) {
      pitch_bend = global_pitch_bends[p];
      events.push({
        // delta: <computed later>
        _time: pitch_bend.time,
        type: MIDIEvents.EVENT_MIDI,
        subtype: MIDIEvents.EVENT_MIDI_PITCH_BEND,
        channel: 0,
        param1: 0,
        param2: (pitch_bend.value + 1) * 64
      });
    }
//			param2: ((pitch_bend.value + 1) * 0x2000) / 128
//			param2: pitch_bend.value * 0x2000 / 128 + 64
//			param2: pitch_bend.value * 0x1000 / 64 + 64
    for (q = 0, len6 = global_instrument_selects.length; q < len6; q++) {
      instrument_select = global_instrument_selects[q];
      events.push({
        // delta: <computed later>
        _time: instrument_select.time,
        type: MIDIEvents.EVENT_MIDI,
        subtype: MIDIEvents.EVENT_MIDI_PROGRAM_CHANGE,
        channel: 0,
        param1: instrument_select.value
      });
    }
    for (r = 0, len7 = global_bank_msb_selects.length; r < len7; r++) {
      bank_msb_select = global_bank_msb_selects[r];
      events.push({
        // delta: <computed later>
        _time: bank_msb_select.time,
        type: MIDIEvents.EVENT_MIDI,
        subtype: 0, // Bank Select Coarse (MSB) (Most Significant Byte)
        channel: 0,
        param1: bank_msb_select.value
      });
    }
    for (s = 0, len8 = global_bank_lsb_selects.length; s < len8; s++) {
      bank_lsb_select = global_bank_lsb_selects[s];
      events.push({
        // delta: <computed later>
        _time: bank_lsb_select.time,
        type: MIDIEvents.EVENT_MIDI,
        subtype: 32, // Bank Select Fine (LSB) (Least Significant Byte)
        channel: 0,
        param1: bank_lsb_select.value
      });
    }
    for (u = 0, len9 = global_sustain_periods.length; u < len9; u++) {
      sustain_period = global_sustain_periods[u];
      events.push({
        // delta: <computed later>
        _time: sustain_period.start_time,
        type: MIDIEvents.EVENT_MIDI,
        subtype: MIDIEvents.EVENT_MIDI_CONTROLLER,
        channel: 0,
        param1: 64,
        param2: 127
      });
      events.push({
        // delta: <computed later>
        _time: (ref3 = sustain_period.end_time) != null ? ref3 : performance.now(),
        type: MIDIEvents.EVENT_MIDI,
        subtype: MIDIEvents.EVENT_MIDI_CONTROLLER,
        channel: 0,
        param1: 64,
        param2: 0
      });
    }
    events = events.filter(function(event) {
      return isFinite(event._time);
    });
    events.sort(function(a, b) {
      return a._time - b._time;
    });
    total_track_time_ms = events[events.length - 1]._time - events[0]._time;
    total_track_time_ms += 1000; // extra time for notes to ring out
    BPM = 120; // beats per minute
    PPQN = 192; // pulses per quarter note
    pulses_per_ms = PPQN * BPM / 60000;
    total_track_time_seconds = total_track_time_ms / 1000;
    last_time = null;
    for (v = 0, len10 = events.length; v < len10; v++) {
      event = events[v];
      if (event.delta == null) {
        if (last_time != null) {
          event.delta = (event._time - last_time) * pulses_per_ms;
        } else {
          event.delta = 0;
        }
        if (isFinite(event._time)) {
          last_time = event._time;
        }
      }
      delete event._time;
    }
    events.push({
      delta: 0,
      type: MIDIEvents.EVENT_META,
      subtype: MIDIEvents.EVENT_META_END_OF_TRACK,
      length: 0
    });
    first_track_events = [
      {
        delta: 0,
        type: MIDIEvents.EVENT_META,
        subtype: MIDIEvents.EVENT_META_TIME_SIGNATURE,
        length: 4,
        data: [4,
      2,
      24,
      8],
        param1: 4,
        param2: 2,
        param3: 24,
        param4: 8
      },
      {
        delta: 0,
        type: MIDIEvents.EVENT_META,
        subtype: MIDIEvents.EVENT_META_SET_TEMPO,
        length: 3,
        tempo: 60000000 / BPM
      },
      {
        //		{
        //			delta: 0
        //			type: MIDIEvents.EVENT_META
        //			subtype: MIDIEvents.EVENT_META_TRACK_NAME
        //			length: 0 # TODO: name "Tempo track" / "Meta track" / "Conductor track"
        //		}
        delta: ~~(total_track_time_ms * pulses_per_ms),
        type: MIDIEvents.EVENT_META,
        subtype: MIDIEvents.EVENT_META_END_OF_TRACK,
        length: 0
      }
    ];
    midi_file.setTrackEvents(0, first_track_events);
    midi_file.addTrack(1);
    midi_file.setTrackEvents(1, events);
    //	console.log({first_track_events, events})
    output_array_buffer = midi_file.getContent();
    blob = new Blob([output_array_buffer], {
      type: "audio/midi"
    });
    if (!file_name) {
      // Colons are optional in ISO 8601 format, and invalid in Windows filenames.
      // Sub-second precision is optional and unnecessary.
      iso_date_string = new Date(last_note_datetime).toISOString().replace(/:/g, "").replace(/\..*Z/, "Z");
      // Sanitize filename in a fun way
      // We don't need to worry about Windows reserved filenames, dot or space at end of filename, length, etc.
      // because the browser should take care of that,
      // but the browser will sanitize reserved characters in a bland way,
      // such as replacing with underscores.
      // I want to preserve the intention as much as possible, of the entered name.
      recording_name = recording_name_input.value;
      recording_name = recording_name.replace(/\//g, "⧸");
      recording_name = recording_name.replace(/\\/g, "⧹");
      recording_name = recording_name.replace(/</g, "ᐸ");
      recording_name = recording_name.replace(/>/g, "ᐳ");
      recording_name = recording_name.replace(/:/g, "꞉");
      recording_name = recording_name.replace(/\|/g, "∣");
      recording_name = recording_name.replace(/\?/g, "？");
      recording_name = recording_name.replace(/\*/g, "∗");
      recording_name = recording_name.replace(/(^|[-—\s(\["])'/g, "$1\u2018"); // opening singles
      recording_name = recording_name.replace(/'/g, "\u2019"); // closing singles & apostrophes
      recording_name = recording_name.replace(/(^|[-—\/\[(‘\s])"/g, "$1\u201c"); // opening doubles
      recording_name = recording_name.replace(/"/g, "\u201d"); // closing doubles
      recording_name = recording_name.replace(/--/g, "\u2014"); // em-dashes
      recording_name = recording_name.replace(/\.\.\./g, "…"); // ellipses
      recording_name = recording_name.replace(/~/g, "\u301C"); // Chrome at least doesn't like tildes
      recording_name = recording_name.trim();
      file_name = `${iso_date_string}${recording_name.length ? ` - ${recording_name}` : ""}.midi`;
    }
    saveAs(blob, file_name);
    try {
      // TODO: timeout?? I wish there was a way to tell if and when the file was actually saved!
      // probably a multi-tier recovery system is needed, where possibly-saved/recovered recordings are hidden, but still recoverable, for some number of days
      return localStorage[`to_delete:${active_recording_session_id}`] = `${delete_later_reason} ${new Date().toISOString()}`;
    } catch (error1) {}
  };

  //#############################
  // User Interface
  //#############################
  fullscreen_button.onclick = function() {
    if (fullscreen_target_el.requestFullscreen) {
      return fullscreen_target_el.requestFullscreen();
    } else if (fullscreen_target_el.mozRequestFullScreen) {
      return fullscreen_target_el.mozRequestFullScreen();
    } else if (fullscreen_target_el.webkitRequestFullScreen) {
      return fullscreen_target_el.webkitRequestFullScreen();
    }
  };

  arrow_size = 10;

  troubleshoot_midi_input_popover.style.setProperty("--arrow-size", `${arrow_size}px`);

  troubleshooting_popper = Popper.createPopper(troubleshoot_midi_input_button, troubleshoot_midi_input_popover, {
    modifiers: [
      {
        name: 'offset',
        options: {
          offset: [0,
      arrow_size + 5]
        }
      }
    ]
  });

  troubleshoot_midi_input_button.onclick = function() {
    if (troubleshoot_midi_input_button.getAttribute("aria-expanded") === "false") {
      troubleshoot_midi_input_button.setAttribute("aria-expanded", "true");
      troubleshoot_midi_input_popover.hidden = false;
      return troubleshooting_popper.update();
    } else {
      troubleshoot_midi_input_button.setAttribute("aria-expanded", "false");
      return troubleshoot_midi_input_popover.hidden = true;
    }
  };

  // close the popover when the user clicks outside of it
  window.addEventListener("click", function(event) {
    if (troubleshoot_midi_input_button.getAttribute("aria-expanded") === "true" && !(troubleshoot_midi_input_button.contains(event.target) || troubleshoot_midi_input_popover.contains(event.target))) {
      event.preventDefault(); // won't prevent much, would need an overlay to prevent clicks from going through
      troubleshoot_midi_input_button.setAttribute("aria-expanded", "false");
      return troubleshoot_midi_input_popover.hidden = true;
    }
  });

  // close popover when user presses escape
  window.addEventListener("keydown", function() {
    if (event.key === "Escape" && troubleshoot_midi_input_button.getAttribute("aria-expanded") === "true") {
      troubleshoot_midi_input_button.setAttribute("aria-expanded", "false");
      return troubleshoot_midi_input_popover.hidden = true;
    }
  });

  end_learn_range = function() {
    var cancel_learn_range_button_was_focused;
    // in case of apply button, selected_range is already set to learning_range
    // in case of cancel button, selected_range is not set to learning_range so this does a reset
    cancel_learn_range_button_was_focused = cancel_learn_range_button === document.activeElement;
    is_learning_range = false;
    cancel_learn_range_button.hidden = true;
    apply_text_el.hidden = true;
    learn_range_text_el.hidden = false;
    learning_range = [null, null];
    midi_range_left_input.disabled = !visualization_enabled;
    midi_range_right_input.disabled = !visualization_enabled;
    [midi_range_left_input.value, midi_range_right_input.value] = selected_range;
    if (cancel_learn_range_button_was_focused) {
      return learn_range_or_apply_button.focus();
    }
  };

  learn_range_or_apply_button.onclick = function() {
    if (is_learning_range) {
      // order matters here: set_selected_range uses is_learning_range,
      // end_learn_range uses selected_range
      is_learning_range = false;
      set_selected_range(learning_range);
      end_learn_range();
      return save_options_soon({
        update_even_focused_inputs: true
      });
    } else {
      is_learning_range = true;
      cancel_learn_range_button.hidden = false;
      apply_text_el.hidden = false;
      learn_range_text_el.hidden = true;
      learning_range = [null, null];
      midi_range_left_input.disabled = true;
      midi_range_right_input.disabled = true;
      return [midi_range_left_input.value, midi_range_right_input.value] = view_range_while_learning;
    }
  };

  cancel_learn_range_button.onclick = end_learn_range;

  // supposedly keydown doesn't work consistently in all browsers
  document.body.addEventListener("keydown", function(event) {
    if (event.key === "Escape") {
      end_learn_range();
    }
    if ((event.key === "s" || event.key === "S") && (event.ctrlKey || event.metaKey)) {
      export_midi_file("saved");
      return event.preventDefault();
    }
  });

  document.body.addEventListener("keyup", function(event) {
    if (event.key === "Escape") {
      return end_learn_range();
    }
  });

  //#############################
  // Device Discovery Helper
  //#############################
  midi_discovery_iframe = document.createElement("iframe");

  midi_discovery_iframe.style.position = "absolute";

  midi_discovery_iframe.style.top = "-100%";

  midi_discovery_iframe.style.left = "-100%";

  midi_discovery_iframe.style.opacity = 0;

  midi_discovery_iframe.style.pointerEvents = "none";

  midi_discovery_iframe.tabIndex = -1;

  midi_discovery_iframe.setAttribute("aria-hidden", "true");

  midi_discovery_iframe.title = "This iframe is for discovering MIDI devices, to work around devices not connecting, or not showing up, until the page is refreshed.";

  document.body.appendChild(midi_discovery_iframe);

  midi_discovery_iframe.addEventListener("load", function() {
    var error, iframe_window;
    try {
      iframe_window = midi_discovery_iframe.contentWindow;
      setTimeout(function() {
        return iframe_window.location.reload();
      }, 5000);
      on_success = function(midi) {
        var handle_midi_input, midi_inputs;
        midi_inputs = [...new Map(midi.inputs).values()];
        // console.log 'From MIDI discovery iframe, inputs: ', midi_inputs
        handle_midi_input = function(midi_input) {
          if (midi_input.state === "connected") {
            // give some time for the app to connect to the midi device
            return setTimeout(function() {
              if (!connected_port_ids.has(midi_input.id)) {
                // don't reload if notes have been recorded
                // TODO: now that notes are saved to IndexedDB, maybe reload
                // as long as you're not actively playing?
                if (!notes.length) {
                  return location.reload(); // reload the whole app so it'll get the new MIDI device
                }
              }
            }, 500);
          }
        };
        midi_inputs.forEach(handle_midi_input);
        return midi.onstatechange = function(e) {
          if (e.port.type === "input") {
            return handle_midi_input(e.port);
          }
        };
      };
      on_error = function(error) {
        return console.log("requestMIDIAccess for MIDI discovery iframe failed:", error);
      };
      if (iframe_window.navigator.requestMIDIAccess) {
        return iframe_window.navigator.requestMIDIAccess().then(on_success, on_error);
      }
    } catch (error1) {
      // else
      // a message should already be shown
      error = error1;
      return console.log("Failed to access iframe for MIDI discovery");
    }
  });

}).call(this);
